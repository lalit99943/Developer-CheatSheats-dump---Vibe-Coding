import { CheatSheet } from '../../types';

export const regexCheatSheets: CheatSheet[] = [
  {
    id: 'regex-1',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Basic Characters and Anchors',
    snippet: 'cat    // Matches the literal string "cat"\n^cat   // Matches "cat" at the beginning of a string\ncat$   // Matches "cat" at the end of a string\n^cat$  // Matches the exact string "cat"',
    description: 'Literal characters match themselves. Anchors (`^`, `$`) are used to match the beginning or end of a string or line.',
    tags: ['regex', 'basics', 'anchor', 'start', 'end'],
  },
  {
    id: 'regex-2',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Quantifiers',
    snippet: 'a*     // Matches "a" zero or more times\na+     // Matches "a" one or more times\na?     // Matches "a" zero or one time\na{3}   // Matches "a" exactly 3 times\na{3,5} // Matches "a" 3 to 5 times',
    description: 'Quantifiers specify how many times a character, group, or character class must be present in the input for a match to be found.',
    tags: ['regex', 'quantifier', 'repeat', 'star', 'plus', 'optional'],
  },
  {
    id: 'regex-3',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Character Classes',
    snippet: '.      // Matches any single character (except newline)\n\\d     // Matches any digit (0-9)\n\\w     // Matches any word character (a-z, A-Z, 0-9, _)\n\\s     // Matches any whitespace character (space, tab, newline)',
    description: 'Character classes (or character sets) are special notations that match any character from a certain set.',
    tags: ['regex', 'character class', 'digit', 'word', 'whitespace', 'dot'],
  },
  {
    id: 'regex-4',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Custom Character Sets',
    snippet: '[abc]  // Matches "a", "b", or "c"\n[^abc] // Matches any character except "a", "b", or "c"\n[a-z]  // Matches any lowercase letter from "a" to "z"',
    description: 'Use square brackets `[]` to create a custom set of characters to match. A caret `^` inside the brackets negates the set.',
    tags: ['regex', 'character set', 'square brackets', 'range', 'negation'],
  },
  {
    id: 'regex-5',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Grouping and Capturing',
    snippet: '(abc)+   // Matches "abc" one or more times\n(a|b)c   // Matches "ac" or "bc"',
    description: 'Parentheses `()` create a capturing group. This allows you to apply quantifiers to a whole group or use the OR `|` operator within the group.',
    tags: ['regex', 'group', 'capture', 'parentheses', 'or', 'alternation'],
  },
  {
    id: 'regex-6',
    category: 'RegEx',
    subCategory: 'javascript',
    title: 'Using RegEx in JavaScript',
    snippet: 'const regex = /\\d+/g;\nconst str = "There are 123 apples and 456 oranges.";\n\n// Test for a match\nconsole.log(regex.test(str)); // true\n\n// Find all matches\nconsole.log(str.match(regex)); // ["123", "456"]',
    description: 'In JavaScript, you can create a regular expression using literal syntax `/.../` or the `new RegExp()` constructor. The `.test()` method checks for a match, and the string `.match()` method finds matches.',
    tags: ['regex', 'javascript', 'test', 'match', 'usage'],
  },
  {
    id: 'regex-7',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Common Flags',
    snippet: '/pattern/g   // Global: Find all matches, not just the first\n/pattern/i   // Case-insensitive: Match "a" and "A"\n/pattern/m   // Multi-line: ^ and $ match start/end of lines, not just the whole string',
    description: 'Flags are placed after the closing slash of a regular expression and modify its behavior.',
    tags: ['regex', 'flags', 'global', 'case-insensitive', 'multi-line'],
  },
  {
    id: 'regex-8',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Word Boundary',
    snippet: '\\bcat\\b  // Matches the word "cat", but not in "caterpillar"',
    description: '`\\b` is a zero-width assertion that matches a "word boundary": a position between a word character (`\\w`) and a non-word character (`\\W`) or string anchor.',
    tags: ['regex', 'word boundary', 'anchor', 'assertion'],
  },
  {
    id: 'regex-9',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Example: Match an Email Address',
    snippet: '/^[\\w\\.-]+@[\\w\\.-]+\\.[a-zA-Z]{2,7}$/',
    description: 'A practical example of a regex for validating a standard email format. It checks for a username part, an @ symbol, a domain part, and a top-level domain.',
    tags: ['regex', 'example', 'email', 'validation'],
  },
  {
    id: 'regex-10',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Example: Extract URL Components',
    snippet: '/^(https?):\\/\\/([^\\/]+)(\\/.*)?$/',
    description: 'This regex uses capturing groups to extract the protocol (http or https), the domain name, and the path from a URL. Group 1 captures the protocol, Group 2 captures the domain.',
    tags: ['regex', 'example', 'url', 'parsing', 'capture group'],
  },
  {
    id: 'regex-11',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Non-Capturing Group',
    snippet: '/(?:abc)+/',
    description: 'Using `(?:...)` creates a non-capturing group. It groups characters together so you can apply quantifiers, but it doesn\'t capture the matched text. This is more efficient if you don\'t need to reference the group later.',
    tags: ['regex', 'group', 'non-capturing', 'performance'],
  },
  {
    id: 'regex-12',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Lookaheads (Positive and Negative)',
    snippet: 'a(?=b)  // Positive Lookahead: Matches "a" only if it is followed by "b"\na(?!b)   // Negative Lookahead: Matches "a" only if it is NOT followed by "b"',
    description: 'Lookaheads are zero-width assertions that check for a pattern without consuming characters. This allows you to match based on context that comes after your main pattern.',
    tags: ['regex', 'lookahead', 'assertion', 'positive', 'negative'],
  },
  {
    id: 'regex-13',
    category: 'RegEx',
    subCategory: 'regex',
    title: 'Greedy vs. Lazy Matching',
    snippet: `Greedy (default): <h1>.*</h1>  // Matches from the first <h1> to the last </h1> on the line
Lazy:           <h1>.*?</h1> // Matches from one <h1> to the very next </h1>`,
    description: 'Quantifiers (`*`, `+`, `{}`) are "greedy" by default, meaning they match as much text as possible. Appending a `?` to a quantifier makes it "lazy", meaning it will match as little text as possible.',
    tags: ['regex', 'greedy', 'lazy', 'quantifier', 'optimization'],
  },
];